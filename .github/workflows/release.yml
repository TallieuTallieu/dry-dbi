name: Automated Release and Tagging

on:
  # Trigger only when pull requests to master are merged
  push:
    branches: 
      - master

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for changelog generation
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          tools: composer

      - name: Install dependencies
        run: composer install --no-dev --optimize-autoloader

      - name: Determine version bump and calculate new version
        id: get_version
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          echo "Current branch: $BRANCH_NAME"
          
          # Get current version from composer.json
          if [ -f "composer.json" ]; then
            CURRENT_VERSION=$(php -r "
              \$composer = json_decode(file_get_contents('composer.json'), true);
              echo isset(\$composer['version']) ? \$composer['version'] : '';
            ")
            if [ -z "$CURRENT_VERSION" ]; then
              echo "Error: No version found in composer.json"
              exit 1
            fi
          else
            echo "Error: composer.json not found"
            exit 1
          fi
          
          echo "Current version: $CURRENT_VERSION"
          
          # Auto-detect bump type from branch name
            BUMP_TYPE=""
            
            # PATCH: Bug fixes and patches
            if [[ $BRANCH_NAME =~ ^(bug|fix|hotfix|patch|bugfix)/ ]]; then
              BUMP_TYPE="patch"
              echo "ðŸ› Detected PATCH bump from branch prefix: ${BASH_REMATCH[1]}"
            
            # MINOR: Features and enhancements  
            elif [[ $BRANCH_NAME =~ ^(feature|feat|enhancement|improve|add|update)/ ]]; then
              BUMP_TYPE="minor"
              echo "âœ¨ Detected MINOR bump from branch prefix: ${BASH_REMATCH[1]}"
            
            # MAJOR: Breaking changes
            elif [[ $BRANCH_NAME =~ ^(breaking|major|break|bc-break|breaking-change)/ ]]; then
              BUMP_TYPE="major"
              echo "ðŸ’¥ Detected MAJOR bump from branch prefix: ${BASH_REMATCH[1]}"
            
            # PATCH: Chores and maintenance (default to patch)
            elif [[ $BRANCH_NAME =~ ^(chore|docs|style|refactor|test)/ ]]; then
              BUMP_TYPE="patch"
              echo "ðŸ”§ Detected PATCH bump from maintenance branch: ${BASH_REMATCH[1]}"
            
            # MINOR: Release branches (default to minor)
            elif [[ $BRANCH_NAME =~ ^release/ ]]; then
              BUMP_TYPE="minor"
              echo "ðŸš€ Detected MINOR bump from release branch"
            
            # PATCH: Main branch (default to patch)
            elif [[ $BRANCH_NAME == "main" ]]; then
              BUMP_TYPE="patch"
              echo "ðŸ  Detected PATCH bump from main branch"
            
            # Try to infer from Shortcut branch pattern: feature/sc-XXXX--description
            elif [[ $BRANCH_NAME =~ ^feature/sc-[0-9]+-- ]]; then
              BUMP_TYPE="minor"
              echo "ðŸŽ« Detected MINOR bump from Shortcut feature branch"
            
            # Default to patch for unknown patterns
            else
              BUMP_TYPE="patch"
              echo "â“ Unknown branch pattern, defaulting to PATCH bump"
            fi
          
          # Calculate new version if not manually provided
          if [ -z "$VERSION" ]; then
            # Parse current version
            if [[ $CURRENT_VERSION =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
              PATCH=${BASH_REMATCH[3]}
              
              echo "Parsed version: $MAJOR.$MINOR.$PATCH"
              
              # Apply version bump
              case $BUMP_TYPE in
                "major")
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                "minor")
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                "patch")
                  PATCH=$((PATCH + 1))
                  ;;
                *)
                  echo "Error: Invalid bump type '$BUMP_TYPE'"
                  exit 1
                  ;;
              esac
              
              VERSION="$MAJOR.$MINOR.$PATCH"
            else
              echo "Error: Invalid current version format '$CURRENT_VERSION'"
              exit 1
            fi
          fi
          
          # Validate semantic versioning format
          if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version '$VERSION' does not follow semantic versioning format"
            echo "Expected format: X.Y.Z"
            exit 1
          fi
          
          echo "ðŸ“¦ Version bump: $CURRENT_VERSION â†’ $VERSION ($BUMP_TYPE)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Check if tag already exists
        id: check_tag
        run: |
          TAG="v${{ steps.get_version.outputs.version }}"
          if git tag -l | grep -q "^$TAG$"; then
            echo "Tag $TAG already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Tag $TAG does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Get latest tag for changelog
        id: latest_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tags found"
            echo "tag=" >> $GITHUB_OUTPUT
          else
            echo "Latest tag: $LATEST_TAG"
            echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        id: changelog
        run: |
          TAG="v${{ steps.get_version.outputs.version }}"
          LATEST_TAG="${{ steps.latest_tag.outputs.tag }}"
          
          echo "# Release $TAG" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          
          if [ -n "$LATEST_TAG" ]; then
            echo "## Changes since $LATEST_TAG" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            
            # Get commits since last tag
            git log --pretty=format:"- %s (%h)" $LATEST_TAG..HEAD >> CHANGELOG.md
          else
            echo "## Initial Release" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "This is the first tagged release of dry-dbi." >> CHANGELOG.md
          fi
          
          echo "" >> CHANGELOG.md
          echo "## Installation" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo '```bash' >> CHANGELOG.md
          echo "composer require tallieutallieu/dry-dbi:^${{ steps.get_version.outputs.version }}" >> CHANGELOG.md
          echo '```' >> CHANGELOG.md
          
          # Read changelog content for release notes
          CHANGELOG_CONTENT=$(cat CHANGELOG.md)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update composer.json version
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          BRANCH: ${{ steps.get_version.outputs.branch }}
        run: |
          # Always update composer.json to match the version being released
          echo "Updating composer.json version to $VERSION"
          php -r "
            \$version = getenv('VERSION');
            \$composer = json_decode(file_get_contents('composer.json'), true);
            \$composer['version'] = \$version;
            file_put_contents('composer.json', json_encode(\$composer, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL);
          "
          
          # Commit the version update if there are changes
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if ! git diff --quiet composer.json; then
            git add composer.json
            git commit -m "chore: update composer.json version to $VERSION"
            
            # Push to current branch (not necessarily main)
            git push origin HEAD
            echo "Updated composer.json version to $VERSION"
          else
            echo "composer.json already has version $VERSION, no update needed"
          fi

      - name: Create and push tag
        if: steps.check_tag.outputs.exists == 'false'
        env:
          TAG: v${{ steps.get_version.outputs.version }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a $TAG -m "Release $TAG"
          git push origin $TAG

      - name: Create GitHub Release
        if: steps.check_tag.outputs.exists == 'false'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          release_name: Release v${{ steps.get_version.outputs.version }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false

      - name: Run tests (if available)
        continue-on-error: true
        run: |
          if [ -f "vendor/bin/pest" ]; then
            echo "Running Pest tests..."
            vendor/bin/pest
          elif [ -f "vendor/bin/phpunit" ]; then
            echo "Running PHPUnit tests..."
            vendor/bin/phpunit
          else
            echo "No test runner found, skipping tests"
          fi

      - name: Validate Composer
        run: composer validate --strict

      - name: Summary
        env:
          BRANCH: ${{ steps.get_version.outputs.branch }}
          BUMP_TYPE: ${{ steps.get_version.outputs.bump_type }}
          CURRENT_VERSION: ${{ steps.get_version.outputs.current_version }}
          NEW_VERSION: ${{ steps.get_version.outputs.version }}
          TAG_EXISTS: ${{ steps.check_tag.outputs.exists }}
          TRIGGER: ${{ github.event_name }}
        run: |
          echo "## ðŸš€ Automated Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`$BRANCH\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type**: $BUMP_TYPE ($CURRENT_VERSION â†’ $NEW_VERSION)" >> $GITHUB_STEP_SUMMARY
          echo "- **New Version**: v$NEW_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: v$NEW_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: $TRIGGER" >> $GITHUB_STEP_SUMMARY
          if [ "$TAG_EXISTS" = "true" ]; then
            echo "- **Status**: âš ï¸ Tag already exists, skipped release creation" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: âœ… Release created successfully" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ¿ Branch-Based Version Bump Rules:" >> $GITHUB_STEP_SUMMARY
          echo "| Branch Prefix | Bump Type | Example |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| \`feature/\`, \`feat/\`, \`enhancement/\` | **MINOR** | 3.1.0 â†’ 3.2.0 |" >> $GITHUB_STEP_SUMMARY
          echo "| \`bug/\`, \`fix/\`, \`hotfix/\`, \`patch/\` | **PATCH** | 3.1.0 â†’ 3.1.1 |" >> $GITHUB_STEP_SUMMARY
          echo "| \`breaking/\`, \`major/\`, \`bc-break/\` | **MAJOR** | 3.1.0 â†’ 4.0.0 |" >> $GITHUB_STEP_SUMMARY
          echo "| \`chore/\`, \`docs/\`, \`refactor/\` | **PATCH** | 3.1.0 â†’ 3.1.1 |" >> $GITHUB_STEP_SUMMARY
          echo "| \`main\`, \`release/\` | **PATCH/MINOR** | Auto-detected |" >> $GITHUB_STEP_SUMMARY